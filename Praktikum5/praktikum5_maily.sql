Set SERVEROUTPUT ON;
Set Echo ON;
SPOOL praktikum5_Maily.log;

DROP TABLE staedte CASCADE CONSTRAINTS;

-- ==========================================================
-- Aufgabe 1a)
-- ==========================================================
CREATE TABLE staedte (
    stadt_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    stadtname VARCHAR2(100),                -- Name der Stadt
    breitengrad NUMBER(10,6) NOT NULL,      -- Einheit: Grad (° Nord/Süd)
    laengengrad NUMBER(10,6) NOT NULL       -- Einheit: Grad (° Ost/West)
);
/

-- ==========================================================
-- Aufgabe 1b)
-- ==========================================================
/** 
Muster:
1. Städte sind durch Punkte (.) getrennt
2. Innerhalb jeder Zeile sind Werte durch Leerzeichen getrennt
3. Jede Stadtzeile hat dasselbe Muster
**/
SELECT data FROM user001.webservice_loads WHERE id=2;
/

/** 
Schreib einen PL/SQL-Block, der diesen Text:
    1. zerlegt (jede Stadt einzeln),
    2. umrechnet (Grad + Minuten → Dezimalgrad),
    3. und einfügt (INSERT in staedte)
Ziel: aus einer langen Zeile viele Einzeldatensätze machen
**/

-- -----------------------------------------------------------------------------------------------------------------
-- VIEW ist keine echte Tabelle, sondern eine gespeicherte SQL-Abfrage, die sich wie eine Tabelle verhält
CREATE OR REPLACE VIEW staedte_row
AS WITH rws AS (    -- ist eine Common Table Expression (CTE)
    -- hier wird eine Zeile Text aus user001.webservice_loads geholt
    SELECT data AS str 
    FROM user001.webservice_loads
    WHERE id = 2
)
-- Split-Logik aus Oracle-Blog (REGEXP_SUBSTR + CONNECT BY)
-- Befehl macht aus langen Textzeile mit mehreren Einträgen -> mehrere Zeilen
SELECT
    TRIM(                               -- entfernt überflüssige Leerzeichen am Anfang und Ende
        REGEXP_SUBSTR(                  -- sucht Teilstrings im Text basierend auf einem Muster
            str,                        -- der gesamte Text (z. B. alle Städtedaten)
            '[^.]+',                    -- Muster: „alle Zeichen außer Punkt“ (also bis zum nächsten Punkt)
            1,                          -- Startposition: beginne beim ersten Zeichen
            LEVEL                       -- gibt an, welches Teilstück gelesen wird
        )
    ) AS value                          -- das Ergebnis wird als Spaltenname "value" ausgegeben
FROM rws                                -- liest aus der temporären CTE "rws" (enthält den langen Originaltext)
CONNECT BY LEVEL <=                     -- Wiederhole die Abfrage n-mal
    LENGTH(str) -                       -- Länge des Originaltexts minus
    LENGTH(REPLACE(str, '.')) + 1;      -- Länge des Texts ohne Punkte → ergibt Anzahl der Punkte + 1
                                        -- so oft wird wiederholt, bis jede Teilzeile (zwischen den Punkten) gelesen ist
/

-------------------------------------------------------------------------------------------------------------------------
DECLARE
    v_line VARCHAR2(1000);   -- ganze Zeile (z. B. '50 56 N 6 57 E Köln')
    n_g NUMBER(10,2);        -- Grad Nord
    n_m NUMBER(10,2);        -- Minuten Nord
    o_g NUMBER(10,2);        -- Grad Ost
    o_m NUMBER(10,2);        -- Minuten Ost
    stadtname VARCHAR2(100); -- Stadtname
BEGIN
    FOR r IN (SELECT value FROM staedte_row) LOOP
        -- Zeilenumbrüche entfernen
        v_line := REPLACE(REPLACE(r.value, CHR(10), ''), CHR(13), '');

        -- Werte aus dem Text schneiden
        -- Beispiel: 50 56 N 6 57 E Köln
        n_g := TO_NUMBER(SUBSTR(v_line, 1, 2));   -- Grad Nord (50)
        n_m := TO_NUMBER(SUBSTR(v_line, 5, 2));   -- Minuten Nord (56)
        o_g := TO_NUMBER(SUBSTR(v_line, 12, 1));  -- Grad Ost (6)
        o_m := TO_NUMBER(SUBSTR(v_line, 15, 2));  -- Minuten Ost (57)
        stadtname := SUBSTR(v_line, 22);          -- Stadtname (Köln)

        -- Umrechnung: Grad + Minuten / 60 = Dezimalgrad
        -- Das kann man zwar einfacher lesen 50° 56′, aber das wird später schwer zu berechnen, deswegen 
        -- wandeln wir es in eine Dezimalzahl wie 50.9333 um
        INSERT INTO staedte (stadtname, breitengrad, laengengrad)
        VALUES (
            stadtname,
            n_g + n_m / 60,  -- Breitengrad als Dezimalzahl
            o_g + o_m / 60   -- Längengrad als Dezimalzahl
        );
    END LOOP;

    DBMS_OUTPUT.PUT_LINE('Daten erfolgreich eingefügt.');

EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Fehler: ' || SQLERRM);
END;
/

-- Testen
SELECT * FROM staedte;


-- ==========================================================
-- Aufgabe c)
-- ==========================================================
CREATE OR REPLACE FUNCTION abstand(
    stadt1_in IN VARCHAR2,
    stadt2_in IN VARCHAR2
) RETURN NUMBER IS -- soll eine Zahl zurückgeben
    -- Konstanten
    radius_erde CONSTANT NUMBER := 6371; -- Erdradius in km (oder 6378km je nach Quelle)
    
    -- Koordinaten für Koordinaten beider Städte (Breite = lat, Länge = lon)
    latA NUMBER;    -- Lat A: Breite von Punkt A, ausgedrückt im Bogenmaß
    longA NUMBER;   -- Lat B: Breite von Punkt B, ausgedrückt im Bogenmaß
    latB NUMBER;    -- Long A: Länge von Punkt A, ausgedrückt im Bogenmaß
    longB NUMBER;   -- Long B: Länge von Punkt B, ausgedrückt im Bogenmaß
    
    -- Pi 
    pi CONSTANT NUMBER := ACOS(-1);

    --Differenzen der Winkel (später in Bogenmaß)
    delta_lat NUMBER;
    delta_long NUMBER;

    -- Zwischenwerte der Haversine-Formel
    a NUMBER;
    c NUMBER;

    -- Ergbnis
    distanz NUMBER;
BEGIN
    -- Koordinaten der Städte abrufen
    -- Holt aus Tabelle staedte die Dezimalgrad-Koordinaten für Stadt 1
    SELECT breitengrad, laengengrad INTO latA, longA
    FROM staedte
    WHERE LOWER(stadtname) = LOWER(stadt1_in);

    -- Holt aus Tabelle staedte die Dezimalgrad-Koordinaten für Stadt 2
    SELECT breitengrad, laengengrad INTO latB, longB
    FROM staedte
    WHERE LOWER(stadtname) = LOWER(stadt2_in);

    -- Grad in Bogenmaß umrechnen
    -- WICHTIG trigonometrische Funktionen (SIN, COS) erwarten Radians, nicht Degree!!
    latA := latA * pi / 180;
    longA := longA * pi / 180;
    latB := latB * pi / 180;
    longB := longB * pi / 180;
    
    -- Winkel-Differenzen in Bogenmaß für Formel.
    delta_lat := latB - latA;
    delta_long := longB - longA;

    -- Haversine-Formel anwenden

    -- a beschreibt, wie weit zwei Punkte auf einer Kugel auseinander liegen, aber ohne Winkel und Entfernung zu berücksichtigen.
    -- Wert zwischen 0 und 1, wenn beide Punkte identisch sind -> a = 0 oder wenn sie genau gegenüber auf der Erde sind -> a = 1

    -- Nord-Süd-Differenz 
    a := POWER(SIN(delta_lat / 2), 2)+
        -- Ost-West-Differenz
        -- Längendifferenz ist nicht überall gleich groß, deswegen Skalierung durch COS Faktoren
        -- abhängig vom Breitengrad
        COS(latA) * COS(latB) * POWER(SIN(delta_long / 2), 2);

    -- zentrale Winkel zwischen den beiden Städten
    -- gemessen im Erdmittelpunkt -> sagt wie groß der Winkel zwischen den beiden Orten auf der Kugel ist
    -- Winkel ist proportional zur Entfernung
    c := 2 * ATAN2(SQRT(a), SQRT(1 - a));

    -- Distanz wird berechnet
    distanz := radius_erde * c;

    /**
    d := 2 * radius_erde * ASIN(
            SQRT(
                POWER(SIN((lat2 - lat1) / 2), 2) +
                COS(lat1) * COS(lat2) *
                POWER(SIN((lon2 - lon1) / 2), 2)
            )
        );
    **/
    RETURN distanz;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('Städte wurden nicht gefunden.');
        RETURN NULL;
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Fehler: ' || SQLERRM);
        RETURN NULL;
END;
/


--Testen: Entfernung zwischen Düsseldorf und Köln
DECLARE
    distanz NUMBER;
BEGIN
    -- Test: Entfernung Köln - Düsseldorf
    distanz := abstand('Köln', 'Düsseldorf');

    DBMS_OUTPUT.PUT_LINE(
        'Entfernung zwischen Köln und Düsseldorf: '
        || ROUND(distanz, 2) || ' km'
    );
END;
/


-- ==========================================================
-- Aufgabe 1d)
-- ==========================================================
--In diesem Package existiert eine Prozedur
CREATE OR REPLACE PACKAGE entfernung_pkg AS
    PROCEDURE entfernungs_tabelle;
END entfernung_pkg;
/

CREATE OR REPLACE PACKAGE BODY entfernung_pkg AS

    PROCEDURE entfernungs_tabelle AS
    BEGIN
        -- Ausgabe „Stadt“ linksbündig und auf 20 Zeichen aufgefüllt
        DBMS_OUTPUT.PUT(RPAD('Stadt', 20));  -- Erste Spalte

        -- Schleife über alle Städte alphabetisch sortiert -> erzeugt Spaltenkopf
        FOR stadt IN (SELECT Stadtname FROM Staedte ORDER BY Stadtname) LOOP
            DBMS_OUTPUT.PUT(
                --nimmt die ersten 2 Buchstaben jeder Stadt und macht daraus einen 10-Zeichen breiten rechten Block
                LPAD(SUBSTR(stadt.Stadtname, 1, 2), 10)
            );
        END LOOP;

        -- neue Ausgabezeile beginnen
        DBMS_OUTPUT.NEW_LINE;

        -- Jede Zeile = Ausgangsstadt
        FOR stadt IN (SELECT Stadtname FROM Staedte ORDER BY Stadtname) LOOP

            -- Linke Spalte: voller Name
            DBMS_OUTPUT.PUT(RPAD(stadt.Stadtname, 20));

            -- Für die aktuelle Ausgangsstadt wird jede mögliche Zielstadt durchgegangen
            FOR ziel IN (SELECT Stadtname FROM Staedte ORDER BY Stadtname) LOOP
                -- Abstand zwischen zwei Städten berechnen
                DBMS_OUTPUT.PUT(
                    LPAD(
                        TO_CHAR(abstand(stadt.Stadtname, ziel.Stadtname), 'FM999990.00'),
                        10
                    )
                );
            END LOOP;

            -- neue Ausgabezeile beginnen
            DBMS_OUTPUT.NEW_LINE;

        END LOOP;
    END entfernungs_tabelle;

END entfernung_pkg;
/

-- Testen
EXEC entfernung_pkg.entfernungs_tabelle;


SPOOl OFF;