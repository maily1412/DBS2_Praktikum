SQL> 
SQL> DROP TABLE staedte CASCADE CONSTRAINTS;

Table STAEDTE dropped.

SQL> 
SQL> -- ==========================================================
SQL> -- Aufgabe 1a)
SQL> -- ==========================================================
SQL> CREATE TABLE staedte (
  2      stadt_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  3      stadtname VARCHAR2(100),                -- Name der Stadt
  4      breitengrad NUMBER(10,6) NOT NULL,      -- Einheit: Grad (° Nord/Süd)
  5      laengengrad NUMBER(10,6) NOT NULL       -- Einheit: Grad (° Ost/West)
  6  );

Table STAEDTE created.

SQL> /
SQL> 
SQL> -- ==========================================================
SQL> -- Aufgabe 1b)
SQL> -- ==========================================================
SQL> /** 
SQL>Muster:
SQL>1. Städte sind durch Punkte (.) getrennt
SQL>2. Innerhalb jeder Zeile sind Werte durch Leerzeichen getrennt
SQL>3. Jede Stadtzeile hat dasselbe Muster
SQL>**/
SQL> SELECT data FROM user001.webservice_loads WHERE id=2;

DATA
--------------------------------------------------------------------------------
50° 47‘ N; 6°  5‘ O; Aachen.
50° 44‘ N; 7°  6‘ O; Bonn.
51° 14‘ N; 6° 47‘ O; Düs


SQL> /
SQL> 
SQL> /** 
SQL>Schreib einen PL/SQL-Block, der diesen Text:
SQL>    1. zerlegt (jede Stadt einzeln),
SQL>    2. umrechnet (Grad + Minuten → Dezimalgrad),
SQL>    3. und einfügt (INSERT in staedte)
SQL>Ziel: aus einer langen Zeile viele Einzeldatensätze machen
SQL>**/
SQL> 
SQL> -- -----------------------------------------------------------------------------------------------------------------
SQL> -- VIEW ist keine echte Tabelle, sondern eine gespeicherte SQL-Abfrage, die sich wie eine Tabelle verhält
SQL> CREATE OR REPLACE VIEW staedte_row
  2  AS WITH rws AS (    -- ist eine Common Table Expression (CTE)
  3      -- hier wird eine Zeile Text aus user001.webservice_loads geholt
  4      SELECT data AS str 
  5      FROM user001.webservice_loads
  6      WHERE id = 2
  7  )
  8  -- Split-Logik aus Oracle-Blog (REGEXP_SUBSTR + CONNECT BY)
  9  -- Befehl macht aus langen Textzeile mit mehreren Einträgen -> mehrere Zeilen
 10  SELECT
 11      TRIM(                               -- entfernt überflüssige Leerzeichen am Anfang und Ende
 12          REGEXP_SUBSTR(                  -- sucht Teilstrings im Text basierend auf einem Muster
 13              str,                        -- der gesamte Text (z. B. alle Städtedaten)
 14              '[^.]+',                    -- Muster: „alle Zeichen außer Punkt“ (also bis zum nächsten Punkt)
 15              1,                          -- Startposition: beginne beim ersten Zeichen
 16              LEVEL                       -- gibt an, welches Teilstück gelesen wird
 17          )
 18      ) AS value                          -- das Ergebnis wird als Spaltenname "value" ausgegeben
 19  FROM rws                                -- liest aus der temporären CTE "rws" (enthält den langen Originaltext)
 20  CONNECT BY LEVEL <=                     -- Wiederhole die Abfrage n-mal
 21      LENGTH(str) -                       -- Länge des Originaltexts minus
 22      LENGTH(REPLACE(str, '.')) + 1;

View STAEDTE_ROW created.

SQL>       -- Länge des Texts ohne Punkte → ergibt Anzahl der Punkte + 1
SQL>                                         -- so oft wird wiederholt, bis jede Teilzeile (zwischen den Punkten) gelesen ist
SQL> /
SQL> 
SQL> -------------------------------------------------------------------------------------------------------------------------
SQL> DECLARE
  2      v_line VARCHAR2(1000);   -- ganze Zeile (z. B. '50 56 N 6 57 E Köln')
  3      n_g NUMBER(10,2);        -- Grad Nord
  4      n_m NUMBER(10,2);        -- Minuten Nord
  5      o_g NUMBER(10,2);        -- Grad Ost
  6      o_m NUMBER(10,2);        -- Minuten Ost
  7      stadtname VARCHAR2(100); -- Stadtname
  8  BEGIN
  9      FOR r IN (SELECT value FROM staedte_row) LOOP
 10          -- Zeilenumbrüche entfernen
 11          v_line := REPLACE(REPLACE(r.value, CHR(10), ''), CHR(13), '');
 12  
 13          -- Werte aus dem Text schneiden
 14          -- Beispiel: 50 56 N 6 57 E Köln
 15          n_g := TO_NUMBER(SUBSTR(v_line, 1, 2));   -- Grad Nord (50)
 16          n_m := TO_NUMBER(SUBSTR(v_line, 5, 2));   -- Minuten Nord (56)
 17          o_g := TO_NUMBER(SUBSTR(v_line, 12, 1));  -- Grad Ost (6)
 18          o_m := TO_NUMBER(SUBSTR(v_line, 15, 2));  -- Minuten Ost (57)
 19          stadtname := SUBSTR(v_line, 22);          -- Stadtname (Köln)
 20  
 21          -- Umrechnung: Grad + Minuten / 60 = Dezimalgrad
 22          -- Das kann man zwar einfacher lesen 50° 56′, aber das wird später schwer zu berechnen, deswegen 
 23          -- wandeln wir es in eine Dezimalzahl wie 50.9333 um
 24          INSERT INTO staedte (stadtname, breitengrad, laengengrad)
 25          VALUES (
 26              stadtname,
 27              n_g + n_m / 60,  -- Breitengrad als Dezimalzahl
 28              o_g + o_m / 60   -- Längengrad als Dezimalzahl
 29          );
 30      END LOOP;
 31  
 32      DBMS_OUTPUT.PUT_LINE('Daten erfolgreich eingefügt.');
 33  
 34  EXCEPTION
 35      WHEN OTHERS THEN
 36          DBMS_OUTPUT.PUT_LINE('Fehler: ' || SQLERRM);
 37  END;
 38  /
Fehler: ORA-01400: cannot insert NULL into ("USER022"."STAEDTE"."BREITENGRAD")


PL/SQL procedure successfully completed.

SQL> 
SQL> -- Testen
SQL> SELECT * FROM staedte;

  STADT_ID STADTNAME                                                                                            BREITENGRAD LAENGENGRAD
---------- ---------------------------------------------------------------------------------------------------- ----------- -----------
         1 Aachen                                                                                                 50,783333    6,083333
         2 Bonn                                                                                                   50,733333         7,1
         3 Düsseldorf                                                                                             51,233333    6,783333
         4 Duisburg                                                                                               51,416667    6,766667
         5 Essen                                                                                                      51,45    7,016667
         6 Köln                                                                                                   50,933333        6,95
         7 Krefeld                                                                                                51,333333    6,566667
         8 Leverkusen                                                                                             51,033333    6,983333
         9 Mönchengladbach                                                                                        51,183333        6,45
        10 Mülheim an der Ruhr                                                                                    51,433333    6,883333
        11 Oberhausen                                                                                             51,466667    6,866667

  STADT_ID STADTNAME                                                                                            BREITENGRAD LAENGENGRAD
---------- ---------------------------------------------------------------------------------------------------- ----------- -----------
        12 Remscheid                                                                                              51,183333         7,2
        13 Solingen                                                                                               51,166667    7,083333
        14 Wuppertal                                                                                              51,266667    7,216667

14 rows selected. 

SQL> 
SQL> 
SQL> -- ==========================================================
SQL> -- Aufgabe c)
SQL> -- ==========================================================
SQL> CREATE OR REPLACE FUNCTION abstand(
  2      stadt1_in IN VARCHAR2,
  3      stadt2_in IN VARCHAR2
  4  ) RETURN NUMBER IS -- soll eine Zahl zurückgeben
  5      -- Konstanten
  6      radius_erde CONSTANT NUMBER := 6371; -- Erdradius in km (oder 6378km je nach Quelle)
  7  
  8      -- Koordinaten für Koordinaten beider Städte (Breite = lat, Länge = lon)
  9      latA NUMBER;    -- Lat A: Breite von Punkt A, ausgedrückt im Bogenmaß
 10      longA NUMBER;   -- Lat B: Breite von Punkt B, ausgedrückt im Bogenmaß
 11      latB NUMBER;    -- Long A: Länge von Punkt A, ausgedrückt im Bogenmaß
 12      longB NUMBER;   -- Long B: Länge von Punkt B, ausgedrückt im Bogenmaß
 13  
 14      -- Pi 
 15      pi CONSTANT NUMBER := ACOS(-1);
 16  
 17      --Differenzen der Winkel (später in Bogenmaß)
 18      delta_lat NUMBER;
 19      delta_long NUMBER;
 20  
 21      -- Zwischenwerte der Haversine-Formel
 22      a NUMBER;
 23      c NUMBER;
 24  
 25      -- Ergbnis
 26      distanz NUMBER;
 27  BEGIN
 28      -- Koordinaten der Städte abrufen
 29      -- Holt aus Tabelle staedte die Dezimalgrad-Koordinaten für Stadt 1
 30      SELECT breitengrad, laengengrad INTO latA, longA
 31      FROM staedte
 32      WHERE LOWER(stadtname) = LOWER(stadt1_in);
 33  
 34      -- Holt aus Tabelle staedte die Dezimalgrad-Koordinaten für Stadt 2
 35      SELECT breitengrad, laengengrad INTO latB, longB
 36      FROM staedte
 37      WHERE LOWER(stadtname) = LOWER(stadt2_in);
 38  
 39      -- Grad in Bogenmaß umrechnen
 40      -- WICHTIG trigonometrische Funktionen (SIN, COS) erwarten Radians, nicht Degree!!
 41      latA := latA * pi / 180;
 42      longA := longA * pi / 180;
 43      latB := latB * pi / 180;
 44      longB := longB * pi / 180;
 45  
 46      -- Winkel-Differenzen in Bogenmaß für Formel.
 47      delta_lat := latB - latA;
 48      delta_long := longB - longA;
 49  
 50      -- Haversine-Formel anwenden
 51  
 52      -- a beschreibt, wie weit zwei Punkte auf einer Kugel auseinander liegen, aber ohne Winkel und Entfernung zu berücksichtigen.
 53      -- Wert zwischen 0 und 1, wenn beide Punkte identisch sind -> a = 0 oder wenn sie genau gegenüber auf der Erde sind -> a = 1
 54  
 55      -- Nord-Süd-Differenz 
 56      a := POWER(SIN(delta_lat / 2), 2)+
 57          -- Ost-West-Differenz
 58          -- Längendifferenz ist nicht überall gleich groß, deswegen Skalierung durch COS Faktoren
 59          -- abhängig vom Breitengrad
 60          COS(latA) * COS(latB) * POWER(SIN(delta_long / 2), 2);
 61  
 62      -- zentrale Winkel zwischen den beiden Städten
 63      -- gemessen im Erdmittelpunkt -> sagt wie groß der Winkel zwischen den beiden Orten auf der Kugel ist
 64      -- Winkel ist proportional zur Entfernung
 65      c := 2 * ATAN2(SQRT(a), SQRT(1 - a));
 66  
 67      -- Distanz wird berechnet
 68      distanz := radius_erde * c;
 69  
 70      /**
 71      d := 2 * radius_erde * ASIN(
 72              SQRT(
 73                  POWER(SIN((lat2 - lat1) / 2), 2) +
 74                  COS(lat1) * COS(lat2) *
 75                  POWER(SIN((lon2 - lon1) / 2), 2)
 76              )
 77          );
 78      **/
 79      RETURN distanz;
 80  
 81  EXCEPTION
 82      WHEN NO_DATA_FOUND THEN
 83          DBMS_OUTPUT.PUT_LINE('Städte wurden nicht gefunden.');
 84          RETURN NULL;
 85      WHEN OTHERS THEN
 86          DBMS_OUTPUT.PUT_LINE('Fehler: ' || SQLERRM);
 87          RETURN NULL;
 88  END;
 89  /

Function ABSTAND compiled

SQL> 
SQL> 
SQL> --Testen: Entfernung zwischen Düsseldorf und Köln
SQL> DECLARE
  2      distanz NUMBER;
  3  BEGIN
  4      -- Test: Entfernung Köln - Düsseldorf
  5      distanz := abstand('Köln', 'Düsseldorf');
  6  
  7      DBMS_OUTPUT.PUT_LINE(
  8          'Entfernung zwischen Köln und Düsseldorf: '
  9          || ROUND(distanz, 2) || ' km'
 10      );
 11  END;
 12  /
Entfernung zwischen Köln und Düsseldorf: 35,33 km


PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> -- ==========================================================
SQL> -- Aufgabe 1d)
SQL> -- ==========================================================
SQL> --In diesem Package existiert eine Prozedur
SQL> CREATE OR REPLACE PACKAGE entfernung_pkg AS
  2      PROCEDURE entfernungs_tabelle;
  3  END entfernung_pkg;
  4  /

Package ENTFERNUNG_PKG compiled

SQL> 
SQL> CREATE OR REPLACE PACKAGE BODY entfernung_pkg AS
  2  
  3      PROCEDURE entfernungs_tabelle AS
  4      BEGIN
  5          -- Ausgabe „Stadt“ linksbündig und auf 20 Zeichen aufgefüllt
  6          DBMS_OUTPUT.PUT(RPAD('Stadt', 20));  -- Erste Spalte
  7  
  8          -- Schleife über alle Städte alphabetisch sortiert -> erzeugt Spaltenkopf
  9          FOR stadt IN (SELECT Stadtname FROM Staedte ORDER BY Stadtname) LOOP
 10              DBMS_OUTPUT.PUT(
 11                  --nimmt die ersten 2 Buchstaben jeder Stadt und macht daraus einen 10-Zeichen breiten rechten Block
 12                  LPAD(SUBSTR(stadt.Stadtname, 1, 2), 10)
 13              );
 14          END LOOP;
 15  
 16          -- neue Ausgabezeile beginnen
 17          DBMS_OUTPUT.NEW_LINE;
 18  
 19          -- Jede Zeile = Ausgangsstadt
 20          FOR stadt IN (SELECT Stadtname FROM Staedte ORDER BY Stadtname) LOOP
 21  
 22              -- Linke Spalte: voller Name
 23              DBMS_OUTPUT.PUT(RPAD(stadt.Stadtname, 20));
 24  
 25              -- Für die aktuelle Ausgangsstadt wird jede mögliche Zielstadt durchgegangen
 26              FOR ziel IN (SELECT Stadtname FROM Staedte ORDER BY Stadtname) LOOP
 27                  -- Abstand zwischen zwei Städten berechnen
 28                  DBMS_OUTPUT.PUT(
 29                      LPAD(
 30                          TO_CHAR(abstand(stadt.Stadtname, ziel.Stadtname), 'FM999990.00'),
 31                          10
 32                      )
 33                  );
 34              END LOOP;
 35  
 36              -- neue Ausgabezeile beginnen
 37              DBMS_OUTPUT.NEW_LINE;
 38  
 39          END LOOP;
 40      END entfernungs_tabelle;
 41  
 42  END entfernung_pkg;
 43  /

Package Body ENTFERNUNG_PKG compiled

SQL> 
SQL> -- Testen
SQL> EXEC entfernung_pkg.entfernungs_tabelle;
Stadt                       Aa        Bo        Du        Dü        Es        Kr        Kö        Le        Mö        Mü        Ob        Re        So        Wu
Aachen                    0.00     71.73     85.06     70.02     98.69     69.87     63.08     68.95     51.35     91.34     93.60     89.94     81.97     95.77
Bonn                     71.73      0.00     79.47     59.85     79.90     76.43     24.61     34.35     67.65     79.29     83.15     50.53     48.20     59.86
Duisburg                 85.06     79.47      0.00     20.42     17.72     16.69     55.24     45.22     34.03      8.30      8.89     39.76     35.46     35.43
Düsseldorf               70.02     59.85     20.42      0.00     29.04     18.73     35.33     26.25     23.88     23.30     26.58     29.55     22.18     30.39
Essen                    98.69     79.90     17.72     29.04      0.00     33.81     57.64     46.39     49.30      9.43     10.56     32.27     31.84     24.67
Krefeld                  69.87     76.43     16.69     18.73     33.81      0.00     51.90     44.23     18.55     24.63     25.55     47.12     40.45     45.79
Köln                     63.08     24.61     55.24     35.33     57.64     51.90      0.00     11.36     44.65     55.79     59.59     32.83     27.57     41.48
Leverkusen               68.95     34.35     45.22     26.25     46.39     44.23     11.36      0.00     40.80     45.02     48.86     22.52     16.39     30.63
Mönchengladbach          51.35     67.65     34.03     23.88     49.30     18.55     44.65     40.80      0.00     40.99     42.79     52.28     44.19     54.19
Mülheim an der Ruhr      91.34     79.29      8.30     23.30      9.43     24.63     55.79     45.02     40.99      0.00      3.88     35.46     32.75     29.65
Oberhausen               93.60     83.15      8.89     26.58     10.56     25.55     59.59     48.86     42.79      3.88      0.00     39.10     36.60     32.94
Remscheid                89.94     50.53     39.76     29.55     32.27     47.12     32.83     22.52     52.28     35.46     39.10      0.00      8.34      9.34
Solingen                 81.97     48.20     35.46     22.18     31.84     40.45     27.57     16.39     44.19     32.75     36.60      8.34      0.00     14.49
Wuppertal                95.77     59.86     35.43     30.39     24.67     45.79     41.48     30.63     54.19     29.65     32.94      9.34     14.49      0.00


PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> SPOOl OFF;
